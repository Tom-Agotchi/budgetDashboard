<!DOCTYPE html>
<html>
<head>
  
  <title>Budget Dashboard Thing</title>

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
<!--   <link rel="shortcut icon" type="image/x-icon" href="images/lookitme.png" /> -->

  <script src="d3.v3.5.5.min.js"></script>
<!--   <script src="jquery-2.1.3.min.js"></script>
  <script src="bootstrap-3.3.7-dist/js/bootstrap.min.js"></script> -->

  <style type='text/css'>
    * { 
      -webkit-box-sizing: border-box;
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }

    #main-container{
      margin: auto;
        width: 1250px;
        //border:0px solid #8AC007;
        padding: 0px;
    }

    #chart-controls{
      float: left;
      width: 500px;
      margin: 0px;
      padding-top: 0px;
    }

    #charts{
      float: right;
      width: 750px;
      margin: 0px;
      padding-top: 0px;
    }

    #pie, #bar {
     float: left;
     padding-left: -100px;
    }

    ul#menu {
        padding: 0;
    }

    h1, h5 {
        padding: 0;
        margin-top: 15px;
        margin-left: 4px;
        margin-bottom: 10px;
        float: left;
        padding: 0px 0px;
    }

    h2 {
        padding: 0;
        font-size: 30px;
        margin-top: 0px;
        margin-left: 100px;
        margin-bottom: 0px;
        float: center;
        padding: 15px 0px;
    }

    ul#menu li {
        display: inline;
        padding: 0px 0px;
    }

    li h4 {
      //font-size: 75%;
      line-height: 0;
      display: inline;
    }

    button {
      margin-top: 0px;
    }

    td { 
     padding: 0px;
     margin-left: 0px;
    }

    td.edit { 
     padding: 0px; 
     border: thick white solid; 
    }

    body {
      font-family: sans-serif;
      padding: 0px;
     }

    input.range {
        width: 200px;
     }

    .range-slider {
        
      // Slider
     input.input-range {
        -webkit-appearance: none;
        width: 200px;
        height: 0px;
        border-radius: 0px;
        background: #ccc;
        outline: none;
     
        
        // Slider Handle
        &::-webkit-slider-thumb {
          -webkit-appearance: none;
          width: 0px;
          height: 0px;
          border-radius: 1%;
          background: #353535;
          cursor: pointer;
          -webkit-transition: background .15s ease-in-out;
          transition: background .15s ease-in-out;
          
          &:hover {
            background: #e06161;
          }
       }
        
        &:active::-webkit-slider-thumb {
          background: #e06161;
        }
        
        &::-moz-range-thumb {
          width: 0px;
          height: 0px;
          border: 0;
          border-radius: 1%;
          background: #353535;
          cursor: pointer;
          -webkit-transition: background .15s ease-in-out;
          transition: background .15s ease-in-out;
          
          &:hover {
            background: #e06161;
          }
        }
        
        &:active::-moz-range-thumb {
          background: #e06161;
        }
    }
      
      // Tooltip Tag
      .range-value {
        display: inline-block;
        position: relative;
        width: 60px;
        color: #fff;
        font-size: 20px;
        line-height: 20px;
        text-align: center;
        border-radius: 3px;
        background: #353535;
        padding: 5px 10px;
        margin-left: 7px;
        
        float: right;
        margin-right: 32px;
        margin-top: -20px;
     
        
        &:after {
          position: absolute;
          top: 8px;
          left: -6px;
          width: 0;
          height: 0;
          border-top: 7px solid transparent;
          border-right: 7px solid #353535;
          border-bottom: 7px solid transparent;
          content: '';
          }
      }
    }

    path.slice{
      opacity: .7;
      /* fill: #ccc; */
      stroke: black;
      stroke-width: 1.5px;
      transition: fill 250ms linear;
      transition-delay: 150ms;
    }

    .edit{
      opacity: .7;
      text-align: center;
      background-size: cover;
      color: black;
    }

    text.label {
     opacity:.5;
     font-size: 18px;/* 1.1em ; */
     //color: black;
      //text-shadow: 0px 1px 1px #555;
     color: rgba(0,0,0,5);
     text-shadow: 2px 1px 5px rgba(0,0,0,0.2),
                 0px 1px 2px rgba(255,255,255,0.3);
    }

    dot {
     opacity:.5;
     font-size: 18px;/* 1.1em ; */
     text-anchor: middle;
     //color: black;
      //text-shadow: 0px 1px 1px #555;
     color: rgba(0,0,0,5);
     text-shadow: 2px 1px 5px rgba(0,0,0,0.2),
                 0px 1px 2px rgba(255,255,255,0.3);
    }

    polyline{
      opacity: .25;
      stroke: black;
      stroke-width: 2px;
      fill: none;
    }

    // Firefox Overrides
    ::-moz-range-track {
        background: #ccc;
        border: 0;
    }

    input::-moz-focus-inner { 
      border: 0px; 
    }


    .HideOnLoad {
      opacity: 0;
    }

    label {
      margin-left: 0px;
      display:inline-block;
      width:200px;
      margin-right:30px;
      text-align:right;
    }
    /*
    .chart rect {
      fill: steelblue;
    }
    */
    .chart .legend {
      fill: black;
      font: 12px sans-serif;
      text-anchor: start;
      font-size: 14px;
    }

    .chart text {
      fill: white;
      font: 14px sans-serif;
      text-anchor: end;
    }

    .chart .label {
      fill: black;
      font: 12px sans-serif;
      text-anchor: end;
      font-size: 14px;
    }

    .bar:hover {
      fill: red;
    }

    .axis path,
    .axis line {
      fill: none;
      stroke: #000;
      shape-rendering: crispEdges;
    }

    svg {
      margin-top: 20px;
    }

    #xaxis .domain {
    fill:none;
    stroke:#000;
  }
  #xaxis text, #yaxis text {
    font-size: 12px;
    font-weight: bold;
    fill: dimgray;
  }

/*   .dot {
  font-family: "Helvetica Neue", Helvetica, sans-serif;
  font-size: 12px;
  font-weight: bold;
  fill: white;
  text-anchor: middle;
} */

  </style>
</head>
<body> 
  <div id=main-container>
    <div id=chart-controls>
      <table id=rangebox>
        <tbody>
           <h1 class="HideOnLoadNOT">Monthly Expenses</h1>
        </tbody>
      </table>
      </div>
        <h2 class="HideOnLoadNOT">Budget </h2>
        <label for="Salary1">Annual Salary 1: </label>
       

        <!-- base salary -->
        <input class=txtInpt type="number" id="Salary1" value=130000 onchange="updateTextVals()"/>
        <!-- approximate with bonuses and performance incentive -->
        <!-- <input class=txtInpt type="number" id="Salary1" value=140000 onchange="updateTextVals()"/> -->

        <br>
        <label for="Salary2">Annual Salary 2: </label>
        <input class=txtInpt type="number" id="Salary2" value=49000 onchange="updateTextVals()"/>
        <br>
        <label for="extraIncome">Extra Income (monthly):</label>
        <input class=txtInpt type="number" id="extraIncome" value=0 onchange="updateTextVals()"/>

        <div id=charts>
          <div id=bar></div>
       
          <h2 class="HideOnLoad"><span id="monthlyBudget"></span></h2>
          <h2 class="HideOnLoad"><span id="spent"></span></h2>
          <h2 class="HideOnLoad"><span id="remaining"></span></h2>
          <br>
          <button onclick="toBar()" >Bars</button>
          <button onclick="toPie()" >Pie</button>
      <div id=pie display=hidden></div>
    </div>
    </div>
<script>

    function load_json( path, callback )
    {
      var req = new XMLHttpRequest();
      req.addEventListener( "load", function(){
      
        let obj = JSON.parse( req.responseText );
        
        callback( obj );
      } );
      req.open("GET", path ); //window.location.hostname +
      req.send();
    }

    // function loadJSONsync(path) {
    //     var httpRequest = new XMLHttpRequest();
    //     httpRequest.open('GET', path);
    //     httpRequest.send();
    //     return JSON.parse(httpRequest.responseText);
    // }

    // var colourNames = loadJSONsync( 'colorHexNames.json' );
    // console.log(colourNames)
    
    // colourNames = undefined
    // load_json( 'colorHexNames.json', function( obj ){
    //   var colourNames = obj;
    //   // console.log(colourNames)
    //   return colourNames
    //   })
    

    /*
    RainbowVis-JS 
    Released under Eclipse Public License - v 1.0
    */

    function Rainbow()
    {
      "use strict";
      var gradients = null;
      var minNum = 0;
      var maxNum = 100;
      var colours = ['ff0000', 'ffff00', '00ff00', '0000ff']; 
      setColours(colours);
      
      function setColours (spectrum) 
      {
        if (spectrum.length < 2) {
          throw new Error('Rainbow must have two or more colours.');
        } else {
          var increment = (maxNum - minNum)/(spectrum.length - 1);
          var firstGradient = new ColourGradient();
          firstGradient.setGradient(spectrum[0], spectrum[1]);
          firstGradient.setNumberRange(minNum, minNum + increment);
          gradients = [ firstGradient ];
          
          for (var i = 1; i < spectrum.length - 1; i++) {
            var colourGradient = new ColourGradient();
            colourGradient.setGradient(spectrum[i], spectrum[i + 1]);
            colourGradient.setNumberRange(minNum + increment * i, minNum + increment * (i + 1)); 
            gradients[i] = colourGradient; 
          }

          colours = spectrum;
        }
      }

      this.setSpectrum = function () 
      {
        setColours(arguments);
        return this;
      }

      this.setSpectrumByArray = function (array)
      {
        setColours(array);
        return this;
      }

      this.colourAt = function (number)
      {
        if (isNaN(number)) {
          throw new TypeError(number + ' is not a number');
        } else if (gradients.length === 1) {
          return gradients[0].colourAt(number);
        } else {
          var segment = (maxNum - minNum)/(gradients.length);
          var index = Math.min(Math.floor((Math.max(number, minNum) - minNum)/segment), gradients.length - 1);
          return gradients[index].colourAt(number);
        }
      }

      this.colorAt = this.colourAt;

      this.setNumberRange = function (minNumber, maxNumber)
      {
        if (maxNumber > minNumber) {
          minNum = minNumber;
          maxNum = maxNumber;
          setColours(colours);
        } else {
          throw new RangeError('maxNumber (' + maxNumber + ') is not greater than minNumber (' + minNumber + ')');
        }
        return this;
      }
    }

    function ColourGradient() 
    {
      "use strict";
      var startColour = 'ff0000';
      var endColour = '0000ff';
      var minNum = 0;
      var maxNum = 100;

      this.setGradient = function (colourStart, colourEnd)
      {
        startColour = getHexColour(colourStart);
        endColour = getHexColour(colourEnd);
      }

      this.setNumberRange = function (minNumber, maxNumber)
      {
        if (maxNumber > minNumber) {
          minNum = minNumber;
          maxNum = maxNumber;
        } else {
          throw new RangeError('maxNumber (' + maxNumber + ') is not greater than minNumber (' + minNumber + ')');
        }
      }

      this.colourAt = function (number)
      {
        return calcHex(number, startColour.substring(0,2), endColour.substring(0,2)) 
          + calcHex(number, startColour.substring(2,4), endColour.substring(2,4)) 
          + calcHex(number, startColour.substring(4,6), endColour.substring(4,6));
      }
      
      function calcHex(number, channelStart_Base16, channelEnd_Base16)
      {
        var num = number;
        if (num < minNum) {
          num = minNum;
        }
        if (num > maxNum) {
          num = maxNum;
        } 
        var numRange = maxNum - minNum;
        var cStart_Base10 = parseInt(channelStart_Base16, 16);
        var cEnd_Base10 = parseInt(channelEnd_Base16, 16); 
        var cPerUnit = (cEnd_Base10 - cStart_Base10)/numRange;
        var c_Base10 = Math.round(cPerUnit * (num - minNum) + cStart_Base10);
        return formatHex(c_Base10.toString(16));
      }

      function formatHex(hex) 
      {
        if (hex.length === 1) {
          return '0' + hex;
        } else {
          return hex;
        }
      } 
      
      function isHexColour(string)
      {
        var regex = /^#?[0-9a-fA-F]{6}$/i;
        return regex.test(string);
      }

      function waitOnJSON() {
        if ( !colourNames ) {
         setTimeout(waitOnJSON, 500);
          // window.setInterval(waitOnJSON, 5000);
        }
      }

      function getHexColour(string)
      {
        if (isHexColour(string)) {
          return string.substring(string.length - 6, string.length);
        } else {
          var name = string.toLowerCase();
          waitOnJSON();
          if (colourNames.hasOwnProperty(name)) {
            return colourNames[name];
          }
          throw new Error(string + ' is not a valid colour.');
        }
      }
    // Extended list of CSS colornames s taken from
    // http://www.w3.org/TR/css3-color/#svg-color
    // load_json( 'colorHexNames.json', function( obj ){
    //   var colourNames = obj;
    //   })
    var colourNames = {
    // var test = {
      aliceblue: "F0F8FF",
      antiquewhite: "FAEBD7",
      aqua: "00FFFF",
      aquamarine: "7FFFD4",
      azure: "F0FFFF",
      beige: "F5F5DC",
      bisque: "FFE4C4",
      black: "000000",
      blanchedalmond: "FFEBCD",
      blue: "0000FF",
      blueviolet: "8A2BE2",
      brown: "A52A2A",
      burlywood: "DEB887",
      cadetblue: "5F9EA0",
      chartreuse: "7FFF00",
      chocolate: "D2691E",
      coral: "FF7F50",
      cornflowerblue: "6495ED",
      cornsilk: "FFF8DC",
      crimson: "DC143C",
      cyan: "00FFFF",
      darkblue: "00008B",
      darkcyan: "008B8B",
      darkgoldenrod: "B8860B",
      darkgray: "A9A9A9",
      darkgreen: "006400",
      darkgrey: "A9A9A9",
      darkkhaki: "BDB76B",
      darkmagenta: "8B008B",
      darkolivegreen: "556B2F",
      darkorange: "FF8C00",
      darkorchid: "9932CC",
      darkred: "8B0000",
      darksalmon: "E9967A",
      darkseagreen: "8FBC8F",
      darkslateblue: "483D8B",
      darkslategray: "2F4F4F",
      darkslategrey: "2F4F4F",
      darkturquoise: "00CED1",
      darkviolet: "9400D3",
      deeppink: "FF1493",
      deepskyblue: "00BFFF",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1E90FF",
      firebrick: "B22222",
      floralwhite: "FFFAF0",
      forestgreen: "228B22",
      fuchsia: "FF00FF",
      gainsboro: "DCDCDC",
      ghostwhite: "F8F8FF",
      gold: "FFD700",
      goldenrod: "DAA520",
      gray: "808080",
      green: "008000",
      greenyellow: "ADFF2F",
      grey: "808080",
      honeydew: "F0FFF0",
      hotpink: "FF69B4",
      indianred: "CD5C5C",
      indigo: "4B0082",
      ivory: "FFFFF0",
      khaki: "F0E68C",
      lavender: "E6E6FA",
      lavenderblush: "FFF0F5",
      lawngreen: "7CFC00",
      lemonchiffon: "FFFACD",
      lightblue: "ADD8E6",
      lightcoral: "F08080",
      lightcyan: "E0FFFF",
      lightgoldenrodyellow: "FAFAD2",
      lightgray: "D3D3D3",
      lightgreen: "90EE90",
      lightgrey: "D3D3D3",
      lightpink: "FFB6C1",
      lightsalmon: "FFA07A",
      lightseagreen: "20B2AA",
      lightskyblue: "87CEFA",
      lightslategray: "778899",
      lightslategrey: "778899",
      lightsteelblue: "B0C4DE",
      lightyellow: "FFFFE0",
      lime: "00FF00",
      limegreen: "32CD32",
      linen: "FAF0E6",
      magenta: "FF00FF",
      maroon: "800000",
      mediumaquamarine: "66CDAA",
      mediumblue: "0000CD",
      mediumorchid: "BA55D3",
      mediumpurple: "9370DB",
      mediumseagreen: "3CB371",
      mediumslateblue: "7B68EE",
      mediumspringgreen: "00FA9A",
      mediumturquoise: "48D1CC",
      mediumvioletred: "C71585",
      midnightblue: "191970",
      mintcream: "F5FFFA",
      mistyrose: "FFE4E1",
      moccasin: "FFE4B5",
      navajowhite: "FFDEAD",
      navy: "000080",
      oldlace: "FDF5E6",
      olive: "808000",
      olivedrab: "6B8E23",
      orange: "FFA500",
      orangered: "FF4500",
      orchid: "DA70D6",
      palegoldenrod: "EEE8AA",
      palegreen: "98FB98",
      paleturquoise: "AFEEEE",
      palevioletred: "DB7093",
      papayawhip: "FFEFD5",
      peachpuff: "FFDAB9",
      peru: "CD853F",
      pink: "FFC0CB",
      plum: "DDA0DD",
      powderblue: "B0E0E6",
      purple: "800080",
      red: "FF0000",
      rosybrown: "BC8F8F",
      royalblue: "4169E1",
      saddlebrown: "8B4513",
      salmon: "FA8072",
      sandybrown: "F4A460",
      seagreen: "2E8B57",
      seashell: "FFF5EE",
      sienna: "A0522D",
      silver: "C0C0C0",
      skyblue: "87CEEB",
      slateblue: "6A5ACD",
      slategray: "708090",
      slategrey: "708090",
      snow: "FFFAFA",
      springgreen: "00FF7F",
      steelblue: "4682B4",
      tan: "D2B48C",
      teal: "008080",
      thistle: "D8BFD8",
      tomato: "FF6347",
      turquoise: "40E0D0",
      violet: "EE82EE",
      wheat: "F5DEB3",
      white: "FFFFFF",
      whitesmoke: "F5F5F5",
      yellow: "FFFF00",
      yellowgreen: "9ACD32"
    }
  }

    // function rgbhextoColors( s )
    // {
    //   R = [];
    //   var i = 0;
    //   while( i < s.length ){
      
    //     var rchk = parseInt( s.substr( i, 2 ), 16);
    //     var gchk = parseInt( s.substr( i+2, 2 ), 16);
    //     var bchk = parseInt( s.substr( i+4, 2 ), 16);
        
    //     var f = ( i/s.length );
    //     R.push( [ f, rchk, gchk, bchk, 1 ] );
        
    //     i += 6;
    //   }
    //   return R;
    // }

    // Viridis = rgbhextoColors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725")
    // Plasma = rgbhextoColors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921")
    // Inferno = rgbhextoColors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4")

    //Given a color scale, determine the interpolated color value (colorscale is a [] of [ value, r, g, b, a ] sorted by value from least 0 to greatest 1
    function value_to_color( colorvalue=0, color_scale )
    {
      
      let maxsize = color_scale.length;
      //GET THE FIRST INDEX in a sorted array, that the value is GREATER than colorvalue.
      /*
      let idex2 = maxsize-1;
      for( let i = 0; i < maxsize; i += 1 ){
        if( colorvalue < color_scale[i][0] ){
          idex2 = i;
          break;
        }
      }
      */
      
      /*
      //lower_bound
      //Returns an iterator pointing to the first element in the range [first,last) which does not compare less than val.
      let finali = 0;
      if( true ){
        let l = 0;
        let h = maxsize; // Not n - 1
        while (l < h) {
          let mid = (l + h) >> 1;// / 2;
          if ( colorvalue <= color_scale[mid][0] ) {
            h = mid;
          } else {
            l = mid + 1;
          }
        }
        finali = l;
      }
      */
      
      //this might be more efficient :C stupid javascripts
      let finali = color_scale.findIndex( function(a){ return colorvalue < a[0]; } );
      if( finali < 0 ){ finali = maxsize; }
      
      //there are MORE EFFICIENT techniques for larger arrays.
      //for example, "shooting" can really help lower the range:
      // blindly estimate Math.floor( length * (v - 0) ) and check +- those values.
      //for evenly sorted arrays, this will be near instant.
      //For UNEVEN arrays, "resampling" will greatly improve performance.
      //Knowing something about "radix jumps" can help too.
      //Using a built in lookup jump table helps too (divide each scale into 100 units, make a dict... == log2n but on the JS machine side)
      
      idex2 = finali;
      
      if( idex2 >= maxsize ){
        idex2 = maxsize-1;
        if( idex2 < 0 ){
          idex2 = 0;
        }
      }
      
      let idex = idex2 - 1;
      if( idex < 0 ){
        idex = 0;
      }
      let cd1 = color_scale[idex];
      let cd2 = color_scale[idex2];
      
      let f2 = 0.0
      if( idex2 > idex ){
        f2 = (colorvalue - cd1[0]);
        let delty = cd2[0] - cd1[0];
        if( delty > 0 ){
          f2 /= delty;
        }
      }
      let f1 = 1.0 - f2;
      let rv = Math.floor( f1*cd1[1] + f2*cd2[1] );
      let gv = Math.floor( f1*cd1[2] + f2*cd2[2] );
      let bv = Math.floor( f1*cd1[3] + f2*cd2[3] );
      let av = f1*cd1[4] + f2*cd2[4];
      
      if( rv < 0 ){ rv = 0; }else if( rv > 255 ){ rv = 255; }
      if( gv < 0 ){ gv = 0; }else if( gv > 255 ){ gv = 255; }
      if( bv < 0 ){ bv = 0; }else if( bv > 255 ){ bv = 255; }
      if( av < 0.001 ){ av = 0; }else if( av >= 0.999 ){ av = 1; }  //1000 possible alpha levels with tolerance of 1/1000 of a level...

      return "rgba("+rv+","+gv+","+bv+","+av+")"
    }

    var sal1 = document.getElementById("Salary1").value;
    var sal2 = document.getElementById("Salary2").value;
    var extraIncome = document.getElementById("extraIncome").value;

    var Expenses = [
      {"label":"Mortgage","min":0,"max":2500,"step":0.01,"default":1385}
      ,{"label":"Student Loans", "min":0,"max":500,"step":0.01,"default":233}//PAID OFF!
      ,{"label":"Credit Cards","min":0,"max":800,"step":0.01,"default":(186+180+100+0)}//bank1,bank2,Kohls,Lowes/PAID OFF!
      ,{"label":"Child Care","min":0,"max":2500,"step":0.01,"default":(((385 - (385*.1)) + 455)*2)}
      //TODO: add sal2 retirement
      ,{"label":"Retirement","min":0,"max":6000,"step":0.01,"default":((sal1/26)*0.09)}
      ,{"label":"Taxes","min":0,"max":6000,"step":0.01,"default":((sal1/26)*0.055229)+((sal1/26)*0.057629)+((sal1/26)*0.028187)+((sal1/26)*0.013476)+((sal2/12)*0.167401)}
      ,{"label":"Auto Loan","min":0,"max":800,"step":0.01,"default":340}
      ,{"label":"Cell Phones","min":0,"max":180,"step":0.01,"default":90}
      ,{"label":"Insurance","min":0,"max":1000,"step":0.01,"default":((59*2)+179.78+229+63+5.25+16)}//monthly: benefits, home owners, bank1 auto, hagerty, personal valuables, outdoor water main insurance
      ,{"label":"Gasoline","min":0,"max":500,"step":0.01,"default":(150+150)}
      ,{"label":"Electricity","min":0,"max":160,"step":0.01,"default":156}
      ,{"label":"Gas","min":0,"max":90,"step":0.01,"default":40}
      ,{"label":"Utilities","min":0,"max":300,"step":0.01,"default":85}
      ,{"label":"Pike Pass","min":0,"max":100,"step":0.01,"default":80}
      ,{"label":"Internet","min":0,"max":100,"step":0.01,"default":109}
      ,{"label":"Streaming Services","min":0,"max":60,"step":0.01,"default":(15 + 10 + 13 + 14)}
      ,{"label":"HOA Dues","min":0,"max":450,"step":0.01,"default":(400/12)}
      ,{"label":"Groceries","min":0,"max":500,"step":0.01,"default":480}
      ,{"label":"Medical","min":0,"max":500,"step":0.01,"default":150}//one person sees doc each month lol
      ,{"label":"Baby Stuff","min":0,"max":300,"step":0.01,"default":200}//? (diapers & wipes for home and daycare, medicine, toys, clothes/shoes, ...)
      //leave repairs in to play with but this would come out of remaining/savings
      ,{"label":"Repairs","min":0,"max":1500,"step":0.01,"default":0}
      ,{"label":"Fun","min":0,"max":4000,"step":0.01,"default":240}//60 per week?
      ,{"label":"Savings","min":0,"max":4000,"step":0.01,"default":2000}//just save as much as possible (whatever is left over) but try for 2K/month?
      ,{"label":"Gym","min":0,"max":100,"step":0.01,"default":38}
      ]

    function calcSpent() {
      var total = 0;
      d3.selectAll('#rangebox .range').each(function() {
        total = total + parseFloat(this.value);
      });
      return total;
    }

    var monthlyBudget = (sal1/13)+(sal2/12)+extraIncome;
    //double up sal1 taxes, retirement, and health insurance because sal1 get paid every other week rather than monthly like sal2
    var remaining = monthlyBudget-spent-(((sal1/26)*0.055229)+((sal1/26)*0.057629)+((sal1/26)*0.028187)+((sal1/26)*0.013476)+((sal1/26)*0.05)+((sal1/26)*0.044001)+(180.98+11.25+14.09));

    var nb_sliders = Expenses.length;
    // var nb_sliders = 25; // nb of range sliders
    var moving_id = null; // id of the moved slider
    var oldValue = []; // previous values of the sliders

    // pie chart radius
    var radius = 190;

    // setup the margins so we don't clip the outter labels
    var margin = {
      top: 40,
      right: 50,
      bottom: 50,
      left: 300
    };

    var canvasWidth = radius * 2 + margin.left + margin.right,
      canvasHeight = radius * 2 + margin.top + margin.bottom;

    var numberOfItems = nb_sliders;
    var rainbow = new Rainbow(); 
    rainbow.setNumberRange(1, numberOfItems);
    // rainbow.setSpectrum('red','black');
    // rainbow.setSpectrum('blue', 'orange');
    // rainbow.setSpectrum('black','red','midnightblue','orangered','darkslategray','cyan','purple','gray','blue');
    // rainbow.setSpectrum('orangered','dimgray','white','blue','midnightblue');
    // rainbow.setSpectrum('orangered','midnightblue','white','dimgray','cyan','blue');
    rainbow.setSpectrum('orangered','midnightblue','lightgrey','dimgray','cyan','blue');
    // rainbow.setSpectrum('purple','cyan', 'salmon','orangered', 'red', 'blue');
    var s = '';
    var cs = [];
    for (var i = 1; i <= numberOfItems; i++) {
        var hexColour = rainbow.colourAt(i);
        cs.push( '#' + hexColour );
    }

    function shuffle(array) {
      var currentIndex = array.length, temporaryValue, randomIndex;

      // While there remain elements to shuffle...
      while (0 !== currentIndex) {

        // Pick a remaining element...
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;

        // And swap it with the current element.
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
      }

      return array;
    }

    // cs = shuffle( cs );

    var color = d3.scale.ordinal()
      .range(cs);

    // center legend
    var legendData = [{
      label: "Sample",
      value: 300
    }, {
      label: "Total People",
      value: 7200000
    }]

    var pi = Math.PI; // 3.14

    // pie chart config
    var pie = d3.layout.pie()
      .padAngle(0.02)
      .value(function(d) {
        return d.value;
      })
      //.startAngle(-90 * (pi/180))
      // .endAngle(90 * (pi/180))
      .sort(null);

    // arc object
    var arc = d3.svg.arc()
        .padRadius(radius)
        .outerRadius(radius)
        .innerRadius(radius / 4);
        /*.context(context);*/

    // var dot = "TEST";
    var dot = d3.svg.symbol().type(d3.symbolDiamond);
    /*.context(context);*/

      var arcOver = d3.svg.arc()
        .outerRadius(radius + 20)
        .innerRadius(radius/4);
    /*var arc = d3.svg.arc()
      .outerRadius(radius)
      .innerRadius(radius / 4)
      .padAngle(0.015);*/


    var chartWidth       = 575,
          barHeight        = 22,
          // groupHeight      = barHeight * data.series.length,
          gapBetweenGroups = 10,
          spaceForLabels   = 120,
          spaceForLegend   = 120;

    // initialize the sliders, events and pie chart
    function init() {
      oldValue = [];
      moving_id = null;
      
     
      d3.select('#rangebox tbody').html('');

      // append sliders to table
      for (i = 0; i < nb_sliders; i++) {
        var tr = d3.select('#rangebox tbody').append('tr');
        tr.append('td')
          .attr('class', 'edit')
          .attr('bgcolor', function(d, i){return color(i)})
          .attr('contenteditable', true)
          // .text('' + (i + 1));
          .text(Expenses[i]['label']);
          // console.log(Expenses[i])
        
                
        tr.append('td')
          .append('input')
          .attr('type', 'range')
          .attr('data-id', i)
          .attr('class', 'range')
          .attr('step', Expenses[i]['step'])
          .attr('min', Expenses[i]['min'])
          .attr('max', Expenses[i]['max'])
          .attr('ivalue', Expenses[i]['default']);

        tr.append('td')
          .attr('class', 'range_value');
      }

      d3.selectAll('#rangebox .range').each(function() {
        // var def = parseInt(100 / nb_sliders);
        var def = d3.select(this).attr('ivalue');
        this.value = def;
        oldValue[d3.select(this).attr('ivalue')] = this.value;
      });


      showValues();
      pieChart();
      barChartBetter();
      seteditboxcolor();
     
      // content edit event
      d3.selectAll('.edit').on('input', function() {
        updateLabels();
      });

      // slider event
      d3.selectAll('.range').on('input', function() {
        // this.value = parseInt(this.value);
        this.value = parseFloat(this.value);
        if (this.value < 0) this.value = 0;
        // else if (this.value > 100) this.value = 100;

        var id = d3.select(this).attr('data-id');
        moving_id = id;

        var old_value = oldValue[moving_id];
        var new_value = this.value;
        var delta = (new_value - old_value) / (nb_sliders - 1);

        d3.selectAll('#rangebox .range').each(function() {
          var r_id = d3.select(this).attr('data-id');
          var r_val = this.value;
          // if (r_id != moving_id && r_val > delta) {
          //   var equalized = parseInt(r_val - delta);
          //   this.value = equalized;
          //   oldValue[r_id] = this.value;
          // }
        });

        oldValue[moving_id] = new_value;

        // equalize();
        updateTextVals();
        updateBars();
        showValues();
        updatePieChart();
    
      });
     

      var spent = calcSpent();//calcSpent();
      var remaining = monthlyBudget-spent-(((sal1/26)*0.055229)+((sal1/26)*0.057629)+((sal1/26)*0.028187)+((sal1/26)*0.013476)+((sal1/26)*0.05)+((sal1/26)*0.044001)+(180.98+11.25+14.09));

    }

    // set edit box color to match slice color
    function showHelp() {
      // use jQuery to target h5 edit boxes)
      $(document).ready(function(){
        $('h5').css({"opacity":".4"});
        $('#pieImage').css({"display":"none"});});
    }

    // set edit box color to match slice color
    function seteditboxcolor() {
      // var slicepaths= d3.selectAll('.slice')
         // var mycolors = [0,1,2,3,4,5,6,7,8,9];
         var mycolors = cs;
         var editboxes = d3.selectAll('.edit')
                           .data(mycolors)
                           .attr('bgcolor', function(d){ return color(d); }) 
     }


    // get JSON data from sliders
    function getData() {
      var json = [];
      d3.selectAll('#rangebox .range').each(function() {

        json.push({
          label: d3.select(this.parentNode.parentNode)
            .select('td:first-child')
            .text(),
          value: this.value
        });
      });
      return json;
    }

    // compute total percentage from sliders
    function getTotal() {
      var total = 0;
      d3.selectAll('#rangebox .range').each(function() {
        // total = total + parseInt(this.value);
        total = total + parseFloat(this.value);
      });
      return total;
    }

    // show slider value
    function showValues() {
      d3.selectAll('#rangebox .range').each(function() {
        var perct = this.value// + '%';
        d3.select(this.parentNode.nextSibling).html(perct);
      });
    }

    function updateTextVals() {
      var sal1 = document.getElementById("Salary1").value;
      var sal2 = document.getElementById("Salary2").value;
      var extraIncome = document.getElementById("extraIncome").value;
      var monthlyBudget = (sal1/13)+(sal2/12)+parseFloat(extraIncome);
      // document.getElementById("monthlyBudget").innerHTML=monthlyBudget.toFixed(2);
      document.getElementById("monthlyBudget").value=monthlyBudget.toFixed(2);

      var spent = getTotal();//calcSpent();
      var deductions = (((sal1/26)*0.055229)+((sal1/26)*0.057629)+((sal1/26)*0.028187)+((sal1/26)*0.013476)+((sal1/26)*0.05)+((sal1/26)*0.044001)+(180.98+11.25+14.09));
      var remaining = monthlyBudget-spent-deductions;
      // document.getElementById("spent").innerHTML=spent.toFixed(2);
      // document.getElementById("remaining").innerHTML=remaining.toFixed(2);
      document.getElementById("spent").value=spent.toFixed(2);
      document.getElementById("remaining").value=remaining.toFixed(2);
      updateBars();
    }

    function getTextVals() {
      var sal1 = document.getElementById("Salary1").value;
      var sal2 = document.getElementById("Salary2").value;
      var extraIncome = document.getElementById("extraIncome").value;
      var monthlyBudget = (sal1/13)+(sal2/12)+parseFloat(extraIncome);

      var spent = getTotal();//calcSpent();
      var deductions = (((sal1/26)*0.055229)+((sal1/26)*0.057629)+((sal1/26)*0.028187)+((sal1/26)*0.013476)+((sal1/26)*0.05)+((sal1/26)*0.044001)+(180.98+11.25+14.09));
      var remaining = monthlyBudget-spent-deductions;
      
      return [monthlyBudget.toFixed(2), spent.toFixed(2), remaining.toFixed(2)];
    }

    // draw pie chart
    function pieChart() {

      var json = getData();
      var canvaCenterX = (radius * 2 + margin.left + margin.right) / 2;
      var canvaCenterY = (radius * 2 + margin.top + margin.bottom) / 2;

      d3.select("#pie svg").remove();

      // svg canvas
      var svg = d3.select("#pie")

      .append("svg:svg")
        .attr("width", canvasWidth)
        .attr("height", canvasHeight)

      .append("svg:g")
        .attr("transform", "translate(" + canvasWidth / 2 + "," + canvasHeight / 2 + ")")

      // create the classes under the transform
      d3.select("g")
        .append("g")
        .attr("class", "slices");

      d3.select("g")
        .append("g")
        .attr("class", "labels");

      d3.select("g")
        .append("g")
        .attr("class", "lines");

      d3.select("g")
        .append("g")
        .attr("class", "legend");

      //now in global scope. what a mess :(
      // declare an arc generator function
      /*var arc = d3.svg.arc()
        .outerRadius(radius)
        .innerRadius(radius / 4)
        .padAngle(0.015);

      var arcOver = d3.svg.arc()
        .outerRadius(radius + 20)
        .innerRadius(radius/4);*/

      // group all ther paths into the slices class
      var arcpaths = svg.select(".slices").selectAll("path").data(pie(getData()))
      // render the slices
      arcpaths.enter()
      .append('svg:path')
        .attr("class", "slice")
        .attr("fill", function(d, i) {
          return color(i);
        })
        .attr("d", arc)
        .on("mouseover", function(d) {
            d3.select(this)
               .transition()
               .duration(0)
               .attr("d", arcOver)             
        })
        .on("mouseout", function(d) {
            d3.select(this).transition()            
               .attr("d", arc);
        })
          .each(function(d) {
            this._current = d
        })

        .transition().delay(function(d,i) {
          return i * 12; }).duration(600)
        .attrTween('d', function(d) {
          var i = d3.interpolate(d.startAngle+0.1, d.endAngle);//(1.1*Math.PI+0.1, 3.1*Math.PI);
          return function(t) {
            d.endAngle = i(t); 
            return arc(d)
            }
          })
                 
        /*.attr("d", arc)
          .each(function(d) {
            this._current = d
        })*/
        /*arcpaths.forEach(function(d) {
          var c = arc.centroid(d);
          context.save();
          context.translate(c[0], c[1]);
          dot();
          context.restore();
        });*/

        arcpaths.append('title')
        .text(function(d, i) {
          return json[i].value// + '%';
        });
          
      // group all ther paths into the slices class
      var arclabels = svg.select(".labels")
        .selectAll("label")
        .data(pie(getData()))

      // render the labels
      arclabels.enter()
      
      .append("svg:text")
        .attr("class", "label")
        .attr("transform", function(d) {
          return "translate(" + arc.centroid(d) + ")";
        })
        .attr("text-anchor", "middle")
        .text(function(d, i) {
          if (json[i].value > 1) return json[i].label;
          else return null;
        });
        // uncomment if you want the labels outside the piechart without having to move a slider
        // setTimeout(updatePieChart,600);
     }

     // var chartWidth       = 575,
     //      barHeight        = 22,
     //      // groupHeight      = barHeight * data.series.length,
     //      gapBetweenGroups = 10,
     //      spaceForLabels   = 120,
     //      spaceForLegend   = 120;

     //SO MUCH HARD CODED! Yuck
     function barChartBetter() {
        var categories= ['Monthly Income', 'Spent', 'Remaining'];

        var dollars = getTextVals().map( function (x) {
            return parseInt(x)
          });//[9526,7804,813];

        // var colors = ['#0283AF','#79BCBF','#99C19E'/*,'#99C19E'*/];
        var color = d3.scale.category20();

        var grid = d3.range(16).map(function(i){
          return {'x1':0,'y1':15,'x2':0,'y2':10};
        });

        var tickVals = grid.map(function(d,i){
          if(i>0){ return i*1000; }
          else if(i===0){ return "0";}
        });

        var xscale = d3.scale.linear()
                .domain([0,15000])
                .range([0,622]);

        var yscale = d3.scale.linear()
                .domain([0,categories.length/*+1*/])
                .range([0,60]);

        // var colorScale = d3.scale.quantize()
        //        .domain([0,categories.length])
        //        .range(colors);


        var canvas = d3.select('#bar')
                .append('svg')
                .attr({'width':800,'height':100});

        var grids = canvas.append('g')
                  .attr('id','grid')
                  .attr('transform','translate(100,2)')
                  .selectAll('line')
                  .data(grid)
                  .enter()
                  .append('line')
                  .attr({'x1':function(d,i){ return i/**62*/*(622/15); },
                     'y1':function(d){ return d.y1; },
                     'x2':function(d,i){ return i/**62*/*(622/15); },
                     'y2':function(d){ return d.y2; },
                  })
                  .style({'stroke':'#adadad','stroke-width':'1px'});

        var xAxis = d3.svg.axis();
          xAxis
            .orient('top')
            .scale(xscale)
            .tickValues(tickVals);

        var yAxis = d3.svg.axis();
          yAxis
            .orient('left')
            .scale(yscale)
            .tickSize(1.5)
            .tickFormat(function(d,i){ return categories[i]; })
            .tickValues([0.5,1.5,2.5]/*d3.range(3)*/);

        var y_xis = canvas.append('g')
                  .attr("transform", "translate(100,19)")
                  .attr('id','yaxis')
                  .call(yAxis);

        var x_xis = canvas.append('g')
                  .attr("transform", "translate(99,18)")
                  .attr('id','xaxis')
                  .call(xAxis);

        var chart = canvas.append('g')
                  .attr("transform", "translate(100,0)")
                  .attr('id','bars')
                  .selectAll('rect')
                  .data(dollars)
                  .enter()
                  .append('rect')
                  // .attr("fill", function(d,i) { return color(i % dollars.length); })
                  /*.on("mouseover", function(d) {
                      d3.select(this)
                         .transition()
                         .duration(0)
                         .attr("fill", 'red')             
                  })
                  .on("mouseout", function(d) {
                      d3.select(this).transition()            
                         .attr("fill", function(d,i) { return color(i % dollars.length); });
                  })
                    .each(function(d) {
                      this._current = d
                  })*/
                  .attr('height',19)
                  .attr({'x':0,'y':function(d,i){ return yscale(i)+19; }})
                  // .style('fill',function(d,i){ return colorScale(i); })
                  .attr("fill", function(d,i) { return color(i % dollars.length); })
                  .attr('width',function(d){ return 0; });
                  /*.on("mouseover", function(d) {
                      d3.select(this)
                         .transition()
                         .duration(0)
                         .attr("fill", "red")             
                  })
                  .on("mouseout", function(d) {
                      d3.select(this)//.transition()            
                         .attr("fill", function(d,i) { return color(i % dollars.length); });
                  })
                    .each(function(d) {
                      this._current = d
                  });*/
                  // .attr("stroke", "#333")
                  // .attr("stroke-width", "0px");


        var transit = d3.select("svg").selectAll("rect")
                    .data(dollars)
                    .transition()
                    .duration(600) 
                    .attr("width", function(d) {return xscale(d); });

        var transitext = d3.select('#bars')
                  .selectAll('text')
                  .data(dollars)
                  .enter()
                  .append('text')
                  .attr({'x':function(d) {return xscale(d)-7+"px"/*-50*//*(xscale(d)*0.40)*/; },'y':function(d,i){ return yscale(i)+35; }})
                  .text(function(d){ return d/*+"$"*/; })
                  .style({'fill':/*'black'*/'#fff','font-size':'16px',"text-anchor":'end','font-weight':'bold'})
     }


    function updateBars() {
      var newVals = getTextVals()

      var xscale = d3.scale.linear()
        .domain([0,15000])
        .range([0,622]);

      var yscale = d3.scale.linear()
        .domain([0,newVals.length/*+1*/])
        .range([0,60]);

      var rects = d3.selectAll("rect")
        .data(newVals);
          
      rects
        .attr("width", function(d) {return xscale(d); });
      
      var bartext = d3.select('#bars')
        .selectAll('text')
        .data(newVals);
        

      bartext
        .attr({'x':function(d) {return xscale(d)-7+"px"/*-50*//*(xscale(d)*0.40)*/; },'y':function(d,i){ return yscale(i)+35; }})
        .text(function(d){ return parseInt(d)/*+"$"*/; }).style({'fill':/*'black'*/'#fff','font-size':'16px',"text-anchor":'end','font-weight':'bold'})

  }   

  // var m = [20, 20, 30, 20],
  //       w = 960 - m[1] - m[3],
  //       h = 450 - m[0] - m[2];

        var w = canvasWidth,
        h = canvasHeight;

    var x,
        y,
        duration = 2000,
        delay = 500;

        toBars = function () { 
              var arc, height, margin, pie, radius, width, x;
              width = 750;
              height = width / 2;
              margin = 20;
              radius = (height - (margin * 2)) / 2;
              pie = d3.layout.pie().value(function (d) {
                  return d;
              });
              arc = d3.svg.arc().outerRadius(radius).innerRadius(radius / 4);
              x = d3.scale.linear().domain([0, 100]).range([0, width]);
              svg = d3.select('#pie').select('svg').attr('width', width + (margin * 2)).attr('height', height + (margin * 2));
              // svg.data([percents]);
              var g = svg.append('g').attr('transform', "translate(" + radius + "," + radius + ")");
              var angleDelta = Math.PI 
              return g.selectAll('path')             
              .transition().duration(1000).attr('d', function (d, index, value) {
                  return d3.svg.arc().outerRadius(radius).innerRadius(radius -25)(d);
              })
              .transition().duration(1000).attr('d', function (d, index, value) {
                var cord, oCord;
                cord = {
                    tl: [0, (10-index) * 20],
                    tr: [d.value * 20, (10-index) * 20],
                    br: [d.value * 20, (10-index) * 20 - 20],
                    bl: [0, (10 - index) * 20 - 20]
                };
                oCord = [cord.tr, cord.br, cord.bl, cord.tl];
                var r = "M " + oCord[0][0] + ", " + oCord[0][1] + "A100,100 0 0,1 " + oCord[1][0] + ", " + oCord[1][1] + "L " + oCord[2][0] + ", " + oCord[2][1] + "A100,100 0 0,0 " + oCord[3][0] + ", " + oCord[3][1] + "         Z";
                return r;
            })
            .transition().duration(0).attr('d', function (d, index, value) {
                var cord, oCord;
                cord = {
                    tl: [0, (10-index) * 20],
                    tr: [d.value * 20, (10-index) * 20],
                    br: [d.value * 20, (10-index) * 20 - 20],
                    bl: [0, (10 - index) * 20 - 20]
                };
                oCord = [cord.tr, cord.br, cord.bl, cord.tl];
                var r = "M " + oCord[0][0] + ", " + oCord[0][1] + "A0,0 0 0,1 " + oCord[1][0] + ", " + oCord[1][1] + "L " + oCord[2][0] + ", " + oCord[2][1] + "A0,0 0 0,0 " + oCord[3][0] + ", " + oCord[3][1] + "         Z";
                return r;
            });

        };

   function toBar(){
    // var svg = d3.select("#pie")
    // return 0;
    data = getData().map(function(d) {
            return {"key": d.label, "sumPrice": d.value};
        });
    // console.log(data)
    x = d3.scale.ordinal();

    y = d3.scale.linear();

    // x.domain(data.map(function(d) {
    //         return d.key;
    //     }))
    //     .rangeRoundBands([0, w], .2);

    x.domain(50)
        .rangeRoundBands([0, w], .2);

    y.domain([0, d3.max(data.map(function(d) {
            return d.sumPrice;
        }))])
        .range([h / 4 - 20, 0]);

    var svg = d3.select("#pie")
      .select("svg");
    //     .attr("width", w + m[1] + m[3])
    //     .attr("height", h + m[0] + m[2])
    //     .append("g")
    //     .attr("transform", "translate(" + m[3] + "," + m[0] + ")");
    
    // var g = svg.selectAll("g");

    //g.selectAll("rect").remove();
    var g = svg.selectAll("g");
    var slices = svg.selectAll(".slices");
    // var paths = slices.select("path");
    var paths = slices.selectAll("path");

    // console.log(paths)
    // slices.selectAll("path")
    paths
        .transition()
        .duration(duration)
        .tween("arc", arcTween);

    //The idea here is to first draw an arc like a bar,
    //then tween the bar-like arc to the donut arc. 
    //Thus, the key is find the initial bar size and position:
    //The initial bar height is approximated by the length of 
    //outside arc: barHeight = init_OuterRadius * init_Angle. 
    //So we can get the startAngle shown in f;
    //(Note that: the measure of angle in d3 starts from vertical y:
    // y    angle
    // |    /   
    // |   /        
    // |  /             
    // |o/
    // |/      
    // )                                       
    function arcTween(d) {
        var path = d3.select(this),
            // text = d3.select(this.parentNode).select("text"),
            // x0 = x(d.data.key),
            // y0 = h - y(d.data.sumPrice); //initial height
            x0 = x(0),
            y0 = h - y(0); //initial height

        console.log(path)
        return function(t) {
            t = 1-t;
            var r = h / 2 / Math.min(1, t + 1e-3),
                //a is stepping factor, starting from 1 to 0,
                //as the timer t goes.
                //A simper alternative: a = 1 - t;
                a = Math.cos(t * Math.PI / 2),
                xx = (-r + (a) * (x0 + x.rangeBand()) + (1 - a) * (w + h) / 2),
                yy = ((a) * h + (1 - a) * h / 2),
                f = {
                    innerRadius: (r - x.rangeBand() / (2 - a)) * a,
                    //pie chart: (r - x.rangeBand() / (2 - a)) * a,
                    outerRadius: r,
                    startAngle: a * (Math.PI / 2 - y0 / r) + (1 - a) * d.startAngle,
                    endAngle: a * (Math.PI / 2) + (1 - a) * d.endAngle
                };


            path.attr("transform", "translate(" + xx + "," + yy + ")");
            path.attr("d", arc(f));
            // text.attr("transform", "translate(" + arc.centroid(f) + ")translate(" + xx + "," + yy + ")rotate(" + ((f.startAngle + f.endAngle) / 2 + 3 * Math.PI / 2) * 180 / Math.PI + ")");
        };
    }
} 

function toPie(){
  //still needs to be modified to resemble toBar()
  // return 0;
    var g = svg.selectAll(".symbol");

    g.selectAll("rect").remove();

    g.selectAll("path")
        .transition()
        .duration(duration)
        .tween("arc", arcTween);

    //The idea here is to first draw an arc like a bar,
    //then tween the bar-like arc to the donut arc. 
    //Thus, the key is find the initial bar size and position:
    //The initial bar height is approximated by the length of 
    //outside arc: barHeight = init_OuterRadius * init_Angle. 
    //So we can get the startAngle shown in f;
    //(Note that: the measure of angle in d3 starts from vertical y:
    // y    angle
    // |    /   
    // |   /        
    // |  /             
    // |o/
    // |/      
    // )                                       
    function arcTween(d) {
        var path = d3.select(this),
            text = d3.select(this.parentNode).select("text"),
            x0 = x(d.data.key),
            y0 = h - y(d.data.sumPrice); //initial height

        return function(t) {
            var r = h / 2 / Math.min(1, t + 1e-3),
                //a is stepping factor, starting from 1 to 0,
                //as the timer t goes.
                //A simper alternative: a = 1 - t;
                a = Math.cos(t * Math.PI / 2),
                xx = (-r + (a) * (x0 + x.rangeBand()) + (1 - a) * (w + h) / 2),
                yy = ((a) * h + (1 - a) * h / 2),
                f = {
                    innerRadius: (r - x.rangeBand() / (2 - a)) * a,
                    //pie chart: (r - x.rangeBand() / (2 - a)) * a,
                    outerRadius: r,
                    startAngle: a * (Math.PI / 2 - y0 / r) + (1 - a) * d.startAngle,
                    endAngle: a * (Math.PI / 2) + (1 - a) * d.endAngle
                };


            path.attr("transform", "translate(" + xx + "," + yy + ")");
            path.attr("d", arc(f));
            text.attr("transform", "translate(" + arc.centroid(f) + ")translate(" + xx + "," + yy + ")rotate(" + ((f.startAngle + f.endAngle) / 2 + 3 * Math.PI / 2) * 180 / Math.PI + ")");
        };
    }
}

    // update pie chart
    function updatePieChart() {
      updateArcs();
      updateLabels();
      updateLabelLines();
      
    }

    // update the slices of the pie chart
    function updateArcs() {
       var json = getData();

      d3.selectAll("#pie path title")
        .text(function(d, i) {
          return json[i].value// + '%';
        });

      d3.selectAll("#pie path")
        .data(pie(json))
        .transition()
        .duration(0)//0)
        .attrTween('d', arcTween);

      //this is really close to working. 
        // need to figure out collision b/w text.dot and text.label?
        // once it displays 'TEST' in center of arc, change var dot to circle
      
      //add dot at center of arc
      /*var svg = d3.select("#pie")
      var arcpaths = svg.select(".slices").selectAll("path").data(pie(getData()))
      arcpaths//.enter()
          .append('dot')
          .each(function(d) {
            var centroid = arc.centroid(d);
            // console.log(centroid)
            d3.select(this)
              .attr('class', 'dot') //'label')
              .attr('x', centroid[0])
              .attr('y', centroid[1])
              .attr('dy', '0.33em')
              .text(dot);
              // console.log(this)
          });*/
    }

    /* ------- TEXT LABELS -------*/
    // update the labels of the pie chart
    function updateLabels() {
      labelr = radius + 40 // radius for label anchor
      var text = d3.selectAll("#pie text")
        .data(pie(getData()))
        .transition()
        .duration(0)//120)

      //labels all around chart
      /*.attr("transform", function(d) {
          var c = arc.centroid(d),
            x = c[0],
            y = c[1],
            // pythagorean theorem for hypotenuse
            h = Math.sqrt(x * x + y * y);
          return "translate(" + (x / h * labelr) + ',' +
            (y / h * labelr) + ")";
        })
        .attr("dy", ".35em")
        .attr("text-anchor", function(d) {
          // are we past the center?
          return (d.endAngle + d.startAngle) / 2 > Math.PI ?
            "end" : "start";
        })*/

        //labels only on sides
        function midAngle(d){
          return d.startAngle + (d.endAngle - d.startAngle)/2;
        }

        text.transition().duration(0)
          .attrTween("transform", function(d) {
            this._current = this._current || d;
            var interpolate = d3.interpolate(this._current, d);
            this._current = interpolate(0);
            return function(t) {
              var d2 = interpolate(t);
              var pos = outerArc.centroid(d2);
              pos[0] = radius * (midAngle(d2) < Math.PI ? 1.1 : -1.1);
              return "translate("+ pos +")";
            };
          })
          .styleTween("text-anchor", function(d){
            this._current = this._current || d;
            var interpolate = d3.interpolate(this._current, d);
            this._current = interpolate(0);
            return function(t) {
              var d2 = interpolate(t);
              return midAngle(d2) < Math.PI ? "start":"end";
            };
          })
    // text.exit()
    // .remove()
      //.text(function(d, i) { return d.value.toFixed(2); });
      .text(function(d, i) {
        if (getData()[i].value > 0) return getData()[i].label;
        else return null;
      })

    }

    /* ------- SLICE TO TEXT POLYLINES -------*/

    var outerArc = d3.svg.arc()
      .innerRadius(radius + 50)
      .outerRadius(radius * .95);

    function midAngle(d) {
      return d.startAngle + ((d.endAngle - d.startAngle) / 2);
    }

    function updateLabelLines() {
      var polyline = d3.select(".lines").selectAll("polyline")
        .data(pie(getData()));

      polyline.enter()
        .append("polyline")


      // w/o underlines
      /*polyline.transition()
        .duration(10)//0)
        .attrTween("points", function(d) {
          this._current = this._current || d;
          var interpolate = d3.interpolate(this._current, d);
          this._current = interpolate(0);
          return function(t) {
            var d2 = interpolate(t);
            var pos = 0; // outerArc.centroid(d2);
           // pos[0] = radius * .95 * (midAngle(d2) < Math.PI ? 1 : -1);
           return [arc.centroid(d2), outerArc.centroid(d2)];
          };
        });*/

      //with underlines
      polyline.transition().duration(0)
      .attrTween("points", function(d){
        this._current = this._current || d;
        var interpolate = d3.interpolate(this._current, d);
        this._current = interpolate(0);
        return function(t) {
          var d2 = interpolate(t);
          var pos = outerArc.centroid(d2);
          pos[0] = radius * 0.95 * (midAngle(d2) < Math.PI ? 1.6 : -1.6);
          return [arc.centroid(d2), outerArc.centroid(d2), pos];
        };      
      });  

      polyline.exit()
        .remove();
    }

    // transition for the arcs
    function arcTween(a) {
      var i = d3.interpolate(this._current, a);
      this._current = i(0);
      return function(t) {
        return arc(i(t));
      };
    }

    function arcHighlight(outerRadius, delay) {
      return function() {
        d3.select(this).transition().delay(delay).attrTween("d", function(d) {
          var i = d3.interpolate(d.outerRadius, outerRadius);
          return function(t) { d.outerRadius = i(t); return arc(d); };
        });
      };
    }


window.onload = init();


</script>
</body>
</html>